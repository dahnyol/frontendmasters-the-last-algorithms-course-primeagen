// Linear Search Lists //
export default function linear_search(haystack: number[], needle: number): boolean {
    // find the needle in the haystack, check if the number is in our array. return true or false
    for (let i = 0; i < haystack.length; ++i) {
        if (haystack[i] === needle) {
            return true;
        }
    }
    return false;
}


// Binary Search List //
export default function bs_list(haystack: number[], needle: number): boolean {
    let low = 0;
    let high = haystack.length;

    do {
        const mid = Math.floor(low + (high - low) / 2);
        const value = haystack[mid];

        if (value === needle) {
            return true;
        } else if (value > needle) {
            // high is inclusive, our needle is lower than our selected mid, search left of our high. 
            high = mid;
        } else {
            // low is exclusive, we do not include the mid as we do not need to search again, our needle is higher than the selected mid, search right, so move our low to throw away all the ones lower than mid
            low = mid + 1
        }
        
    } while (low < high)
    return false;
}


// Two Crystal Ball Problem //
export default function two_crystal_balls(breaks: boolean[]): number {
    // assume the array is big enough to have a sqrt
    // constant jump the sqrt(N) -> math.sqrt(array) -> math.sqrt(breaks.length)
    const jumpAmount = Math.floor(Math.sqrt(breaks.length));
    // use our first crystal ball to see where does it break
    let i = jumpAmount;
    // start at the first jump
    for (; i < breaks.length; i += jumpAmount) {
        // current array value is true, we found a break point, break;
        if (breaks[i]) {
            break;
        }
    }
    // we jump back sqrt(N) 
    i -= jumpAmount;

    // start at the last known point before break  
    // walk linear at most, a sqrt(N) until we find our break
    // && make sure not to jump too far in the arr (i < breaks.length).
    for (let j = 0; j < jumpAmount && i < breaks.length; ++j, ++i) {
        if (breaks[i]) {
            // return the index when it breaks
            return i;
        }
    }
    // crystal ball never breaks
    return -1
}


// Bubble Sort //
export default function bubble_sort(arr: number[]): void {
    // for i ... n
    for (let i = 0; i < arr.length; ++i) {
        // for j ... n - 1 - i
        for (let j = 0; j < arr.length - 1 - i; ++j) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
        }
    }
}